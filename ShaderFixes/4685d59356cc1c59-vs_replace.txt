// Crosshair

cbuffer static_globals : register(b0)
{
  row_major float3x4 m_V : packoffset(c0);
  row_major float3x4 m_inv_V : packoffset(c3);
  row_major float4x4 m_P : packoffset(c6);
  row_major float4x4 m_VP : packoffset(c10);
  float4 timers : packoffset(c14);
  float4 fog_plane : packoffset(c15);
  float4 fog_params : packoffset(c16);
  float4 fog_color : packoffset(c17);
  float4 L_ambient : packoffset(c18);
  float3 L_sun_color : packoffset(c19);
  float3 L_sun_dir_w : packoffset(c20);
  float4 L_hemi_color : packoffset(c21);
  float3 eye_position : packoffset(c22);
  float4 pos_decompression_params : packoffset(c23);
  float4 screen_res : packoffset(c24);
  float3 L_sun_dir_e : packoffset(c25);
  float4 parallax : packoffset(c26);
  float4 rain_params : packoffset(c27);
  float4 pp_img_corrections : packoffset(c28);
  float4 pp_img_cg : packoffset(c29);
  float4 actor_data : packoffset(c30);
}



// 3Dmigoto declarations
#define cmp -
Texture1D<float4> IniParams : register(t120);
Texture2D<float4> StereoParams : register(t125);
Texture2D<float> DepthBuffer : register(t50);

static const float near = 0.0001;
static const float far = 1;

float world_z_from_depth_buffer(float x, float y)
{
    uint width, height;
    float z;

    DepthBuffer.GetDimensions(width, height);

    x = min(max((x / 2 + 0.5) * width, 0), width - 1);
    y = min(max((-y / 2 + 0.5) * height, 0), height - 1);
    z = DepthBuffer.Load(int3(x, y, 0)).x;
    if (z == 1)
        return 0;

  return (far*near/((1-z)*near) + (far*z));
}

float adjust_from_depth_buffer(float x, float y)
{
    float4 stereo = StereoParams.Load(0);
	float4 iniParams = IniParams.Load(0);
	
	if (stereo.x==0) {return 0;}
    float separation = stereo.x; float convergence = stereo.y;
    float old_offset, offset, w, sampled_w, distance;
    uint i;
	
	// Stereo cursor: To improve the accuracy of the stereo cursor, we
    // sample a number of points on the depth buffer, starting at the near
    // clipping plane and working towards original x + separation.
    //
    // You can think of this as a line in three dimensional space that
    // starts at each eye and stretches out towards infinity. We sample 255
    // points along this line (evenly spaced in the X axis) and compare
    // with the depth buffer to find where the line is first intersected.
    //
    // Note: The reason for sampling 255 points came from a restriction in
    // DX9/SM3 where loops had to run a constant number of iterations and
    // there was no way to set that number from within the shader itself.
    // I'm not sure if the same restriction applies in DX11 with SM4/5 - if
    // it doesn't, we could change this to check each pixel instead for
    // better accuracy.
    //
    // Based on DarkStarSword's stereo crosshair code originally developed
    // for Miasmata, adapted to Unity, then translated to HLSL.

    offset = (near - convergence) * separation; // Z = X offset from center
    distance = separation - offset;         // Total distance to cover (separation - starting X offset)

    old_offset = offset;
    for (i = 0; i < 200; i++) {
        offset += distance / 200;

        // Calculate depth for this point on the line:
        w = (separation * convergence * 5.5) / (separation - offset);

        sampled_w = world_z_from_depth_buffer(x + offset, y);
        if (sampled_w == 0)
            return separation;

        // If the sampled depth is closer than the calculated depth,
        // we have found something that intersects the line, so exit
        // the loop and return the last point that was not intersected:
        if (w > sampled_w)
            break;

        old_offset = offset;
    }

    return old_offset;
}


void main(
  float4 v0 : POSITIONT0,
  float4 v1 : COLOR0,
  out float4 o0 : COLOR0,
  out float4 o1 : SV_Position0)
{
  float4 r0;
  uint4 bitmask, uiDest;
  float4 fDest;
  
float4 stereo = StereoParams.Load(0);
float4 iniParams = IniParams.Load(0);

  o0.xyzw = v1.zyxw;
  r0.xy = float2(0.5,0.5) + v0.xy;
  r0.y = dot(r0.yy, screen_res.ww);
  r0.x = dot(r0.xx, screen_res.zz);
  o1.x = -1 + r0.x;
  r0.x = -1 + r0.y;
  o1.y = -r0.x;
  o1.zw = v0.zw;
  
  if (o1.w != 1.0)
  o1.x -=stereo.x * (o1.w - stereo.y);
  o1.x += adjust_from_depth_buffer(0,0);

  return;
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Generated by Microsoft (R) HLSL Shader Compiler 9.29.952.3111
//
//   using 3Dmigoto v1.3.16 on Sat Oct  9 13:42:28 2021
//
//
// Buffer Definitions:
//
// cbuffer static_globals
// {
//
//   row_major float3x4 m_V;            // Offset:    0 Size:    48 [unused]
//   row_major float3x4 m_inv_V;        // Offset:   48 Size:    48 [unused]
//   row_major float4x4 m_P;            // Offset:   96 Size:    64 [unused]
//   row_major float4x4 m_VP;           // Offset:  160 Size:    64 [unused]
//   float4 timers;                     // Offset:  224 Size:    16 [unused]
//   float4 fog_plane;                  // Offset:  240 Size:    16 [unused]
//   float4 fog_params;                 // Offset:  256 Size:    16 [unused]
//   float4 fog_color;                  // Offset:  272 Size:    16 [unused]
//   float4 L_ambient;                  // Offset:  288 Size:    16 [unused]
//   float3 L_sun_color;                // Offset:  304 Size:    12 [unused]
//   float3 L_sun_dir_w;                // Offset:  320 Size:    12 [unused]
//   float4 L_hemi_color;               // Offset:  336 Size:    16 [unused]
//   float3 eye_position;               // Offset:  352 Size:    12 [unused]
//   float4 pos_decompression_params;   // Offset:  368 Size:    16 [unused]
//   float4 screen_res;                 // Offset:  384 Size:    16
//   float3 L_sun_dir_e;                // Offset:  400 Size:    12 [unused]
//   float4 parallax;                   // Offset:  416 Size:    16 [unused]
//   float4 rain_params;                // Offset:  432 Size:    16 [unused]
//   float4 pp_img_corrections;         // Offset:  448 Size:    16 [unused]
//   float4 pp_img_cg;                  // Offset:  464 Size:    16 [unused]
//   float4 actor_data;                 // Offset:  480 Size:    16 [unused]
//
// }
//
//
// Resource Bindings:
//
// Name                                 Type  Format         Dim Slot Elements
// ------------------------------ ---------- ------- ----------- ---- --------
// static_globals                    cbuffer      NA          NA    0        1
//
//
//
// Input signature:
//
// Name                 Index   Mask Register SysValue  Format   Used
// -------------------- ----- ------ -------- -------- ------- ------
// POSITIONT                0   xyzw        0     NONE   float   xyzw
// COLOR                    0   xyzw        1     NONE   float   xyzw
//
//
// Output signature:
//
// Name                 Index   Mask Register SysValue  Format   Used
// -------------------- ----- ------ -------- -------- ------- ------
// COLOR                    0   xyzw        0     NONE   float   xyzw
// SV_Position              0   xyzw        1      POS   float   xyzw
//
vs_5_0
dcl_globalFlags refactoringAllowed
dcl_constantbuffer CB0[25], immediateIndexed
dcl_input v0.xyzw
dcl_input v1.xyzw
dcl_output o0.xyzw
dcl_output_siv o1.xyzw, position
dcl_temps 1
mov o0.xyzw, v1.zyxw
add r0.xy, v0.xyxx, l(0.500000, 0.500000, 0.000000, 0.000000)
dp2 r0.y, r0.yyyy, cb0[24].wwww
dp2 r0.x, r0.xxxx, cb0[24].zzzz
add o1.x, r0.x, l(-1.000000)
add r0.x, r0.y, l(-1.000000)
mov o1.y, -r0.x
mov o1.zw, v0.zzzw
ret
// Approximately 9 instruction slots used

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
